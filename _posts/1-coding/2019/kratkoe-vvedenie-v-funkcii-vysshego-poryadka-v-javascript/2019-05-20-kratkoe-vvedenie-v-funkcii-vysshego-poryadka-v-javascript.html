---
layout: post
title: Краткое введение в функции высшего порядка в JavaScript
description: Используйте функции в качестве данных и раскройте мощные модели. Функция, которая принимает и/или возвращает другую функцию, называется функцией высшего порядка.
categories: coding
catname: Кодинг
fold: kratkoe-vvedenie-v-funkcii-vysshego-poryadka-v-javascript
image: "1.png"
thumb: "1t.png"
og: "1og.png"
lqip: "1s.jpg"
latest: "1lp.png"
permalink: "blog/:categories/:year-:month-:day-:slug.html"
---

<h2>Используйте функции в качестве данных и раскройте мощные модели.</h2>

<h3>Функции высшего порядка</h3>

<p>Функция, которая принимает и/или возвращает другую функцию, называется <strong>функцией высшего порядка.</strong></p>

<p>Она <em>высшего порядка</em>, потому что вместо строк, чисел или булевых значений она идет <em>выше</em>, чтобы работать с функциями.</p>

<p>Функции в JavaScript вы можете:</p>

<ul>
	<li>Хранить их как переменные</li>
	<li>Использовать их в массивах</li>
	<li>Назначить их как свойства объекта (методы)</li>
	<li>Передать их в качестве аргументов</li>
	<li>Вернуть их из других функций</li>
</ul>

<p>Как и у <em>любого набора данных</em>. В этом вся суть.</p>

<h3>Функции работают с данными</h3>

<h4>Строки &ndash; это данные</h4>

<pre>
sayHi = (name) => `Hi, ${name}!`;
result = sayHi('User');

console.log(result); // 'Hi, User!'
</pre>

<h4>Числа — это данные</h4>

<pre>
double = (x) => x * 2;
result = double(4);

console.log(result); // 8
</pre>

<div class="ad-article">
{% include /ad-type-article.html %}
</div>

<h4>Булевы — это данные</h4>

<pre>
getClearance = (allowed) => allowed ?
  'Access granted' :
  'Access denied';

result1 = getClearance(true);
result2 = getClearance(false);

console.log(result1); // 'Access granted'
console.log(result2); // 'Access denied'
</pre>

<h4>Объекты — это данные</h4>

<pre>
getFirstName = (obj) => obj.firstName;
result = getFirstName({
  firstName: 'Yazeed'
});

console.log(result); // 'Yazeed'
</pre>

<h4>Массивы — это данные</h4>

<pre>
len = (array) => array.length;
result = len([1, 2, 3]);

console.log(result); // 3
</pre>

<p>Эти 5 типов являются <a href="https://en.wikipedia.org/wiki/First-class_citizen" target="_blank">объектами первого класса</a> на всех основных языках.</p>

<p>Почему они первого класса? Вы можете передавать их, хранить в переменных и массивах, использовать их в качестве входных данных для расчетов. Вы можете использовать их как <em>любой набор данных</em>.</p>

<h3>4 способа, при которых функции являются данными</h3>

<p><strong>1. Передать их через другую функцию</strong></p>
<p>Функция, которая принимает или возвращает другую функцию становится «высшего порядка». Функции высшего порядка позволяют нам отвлечься от общих действий, таких как <code>map</code>,<code>filter</code>и <code>reduce</code></p>

<p><strong>2. Установить их, как свойства обьекта</strong></p>
<p>Это делает их методами!</p>

<p><strong>3. Хранить их в массивах</strong></p>

<p>Полезно, если вы вызываете список функций в ответ на событие. JavaScript цикл событий работает иминно так!</p>

<p><strong>4. Установить их, как переменные</strong></p>

<p>Привязав функцию, проще ее повторно использовать, особенно каррированые функции, которые сейчас принимают одни параметры, а потом другие!</p>

<h4>Функции как аргументы</h4>

<pre>
isEven = (num) => num % 2 === 0;
result = [1, 2, 3, 4].filter(isEven);

console.log(result); // [2, 4]
</pre>

<p>Посмотрите, как <code>filter</code> использует <code>isEven</code>, чтобы решить, какие числа хранить? <code>isEven</code> <em>функция</em>, которая является параметром для <em>другой функции</em>.</p>

<p>Она вызывается с помощью <code>filter</code> для каждого числа и использует возвращенное значение <code>true</code> или <code>false</code>, чтобы определить, следует ли сохранять или отбрасывать число.</p>

<h4>Возврат Функции</h4>

<pre>add = (x) => (y) => x + y;</pre>

<p><code>add</code> требует два параметра, но не все сразу. Это функция, запрашивающая только <code>x</code>, которая возвращает функцию, запрашивающую только <code>y</code>.</p>

<p>Опять же, это возможно только потому, что JavaScript позволяет функциям быть возвращаемым значением — как строки, числа, булевым и т.д.</p>

<p>Вы по-прежнему можете сразу же предоставить <code>x</code> и <code>y</code>, c двойным вызовом, если хотите.</p>

<pre>
result = add(10)(20);

console.log(result); // 30
</pre>

<p>Или <code>х</code> сейчас, а <code>у</code> позже:</p>

<pre>
add10 = add(10);

result = add10(20);

console.log(result); // 30
</pre>

<p>Давайте рассмотрим последний пример. <code>add10</code> — это результат вызова <code>add</code> с одним параметром. Попробуйте войти в консоль.</p>

<img src="img/coding/kratkoe-vvedenie-v-funkcii-vysshego-poryadka-v-javascript/3.png" alt="console пример">

<p><code>add10</code> — это функция, которая принимает <code>y</code> и возвращает <code>x + y</code>. После того, как вы укажете <code>y</code>, она сразу же рассчитает и вернет вам конечный результат.</p>

<img src="img/coding/kratkoe-vvedenie-v-funkcii-vysshego-poryadka-v-javascript/4.png" alt="console пример">

<h4>Возможность повторного использования</h4>

<p>Вероятно, самое большое преимущество функций высшего порядка — это возможность многократного использования. Без нее лучшие массивов JavaScript — <code>map</code>, <code>filter</code> и <code>reduce</code> — не существовали бы!</p>

<p>Вот список пользователей. Мы собираемся сделать некоторые расчеты с их информацией.</p>

<pre>
users = [{
  name: 'Yazeed',
  age: 25
}, {
  name: 'Sam',
  age: 30
}, {
  name: 'Bill',
  age: 20
}];
</pre>

<h4>Map</h4>

<p>Без функций высшего порядка нам всегда нужны циклы, чтобы имитировать функциональность <code>map</code>.</p>

<pre>
getName = (user) => user.name;
usernames = [];

for (let i = 0; i < users.length; i++) {
  const name = getName(users[i]);

  usernames.push(name);
}

console.log(usernames);
// ["Yazeed", "Sam", "Bill"]
</pre>

<p>Или мы можем сделать так!</p>

<pre>
usernames = users.map(getName);

console.log(usernames);
// ["Yazeed", "Sam", "Bill"]
</pre>

<h4>Filter</h4>

<p>В мире без функций высшего порядка нам все еще нужны циклы, чтобы воссоздать функциональность <code>filter</code>.</p>

<pre>
startsWithB = (string) => string
  .toLowerCase()
  .startsWith('b');

namesStartingWithB = [];

for (let i = 0; i < users.length; i++) {
  if (startsWithB(users[i].name)) {
    namesStartingWithB.push(users[i]);
  }
}

console.log(namesStartingWithB);
// [{ "name": "Bill", "age": 20 }]
</pre>

<p>Или мы можем сделать так!</p>

<pre>
namesStartingWithB = users
  .filter((user) => startsWithB(user.name));

console.log(namesStartingWithB);
// [{ "name": "Bill", "age": 20 }]
</pre>

<h4>Reduce</h4>

<p>Да, <code>reduce</code> тоже... Не может делать крутых вещей без функций высшего порядка! &#x1F601;</p>

<pre>
total = 0;

for (let i = 0; i < users.length; i++) {
  total += users[i].age;
}

console.log(total);
// 75
</pre>

<p>А как вам это?</p>

<pre>
totalAge = users
  .reduce((total, user) => user.age + total, 0);

console.log(totalAge);
// 75
</pre>

<h3>Резюме</h3>

<ul>
	<li>Строки, числа, були, массивы и объекты могут храниться как переменные, массивы и свойства или методы.</li>
	<li>JavaScript обрабатывает функции одинаково.</li>
	<li>Это относится к функциям, которые работают с другими функциями: функции высшего порядка.</li>
	<li>Map, filter, и reduce — яркие примеры и значительно упрощают общие шаблоны, такие как преобразование, поиск и суммирование списков!</li>
</ul>

<p class="source">Перевод статьи <a href="https://medium.freecodecamp.org/a-quick-intro-to-higher-order-functions-in-javascript-1a014f89c6b" target="_blank">&laquo;A quick intro to Higher-Order Functions in JavaScript&raquo;</a></p>
