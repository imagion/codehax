---
layout: post
title: Откройте для себя силу замыканий в VueJS
description: Сегодняшнее технологическое развитие фронтенда требует от разработчиков знания широкого спектра технологий, включая фреймворки, библиотеки и пакеты.
categories: coding
catname: Кодинг
image: "coding/otkrojte-dlya-sebya-silu-zamykanij-v-vuejs/1.jpg"
thumb: "coding/otkrojte-dlya-sebya-silu-zamykanij-v-vuejs/1t.jpg"
og: "coding/otkrojte-dlya-sebya-silu-zamykanij-v-vuejs/1og.jpg"
lqip: "coding/otkrojte-dlya-sebya-silu-zamykanij-v-vuejs/1s.jpg"
latest: "coding/otkrojte-dlya-sebya-silu-zamykanij-v-vuejs/1lp.png"
permalink: "blog/:categories/:year-:month-:day-:slug.html"
---

<p>Сегодняшнее технологическое развитие фронтенда требует от разработчиков знания широкого спектра технологий, включая фреймворки, библиотеки и пакеты.</p>

<p>Неудивительно, что глубокие познания и навыки ванильного JavaScript могут начать распыляться. Независимо от того, изучаете ли вы JavaScript, обновляете свои базовые знания или готовитесь к собеседованиям &rarr; Этот руководство для вас!</p>

<p>Вы узнаете, насколько мощны простые замыкания JavaScript. Имейте в виду, с руководством идет задача. &#x1F4AA; Она о создании элегантного Emoji Picker в VueJS и использовании замыканий с использованием функций высшего порядка.</p>

<p><strong>Давайте начнем!</strong></p>

<h3>Область видимости функции</h3>

<p>Несмотря на то, что замыкания являются одной из самых мощных концепций в JavaScript, они во многом легко игнорируются.</p>

<p>Тем не менее, знание о замыканиях является фундаментальным, поскольку они определяют, к каким переменным имеет доступ функция во время ее выполнения. Точнее, замыкания определяют, к каким областям у функции есть доступ, начиная со своей собственной, через все родительские области вплоть до глобальной области.</p>

<p>Чтобы по-настоящему овладеть замыканиями, важно сначала иметь четкое понимание областей видимости. Вы, вероятно, встречали уже испытали влияние областей видимости. Каждый раз, когда вы выполняете функцию, создается область видимости. Всякий раз, когда вы создаете переменные внутри этой функции, они доступны только из самой функции.</p>

<p>В момент завершения функции (путем достижения оператора <code>return</code> или <code>}</code> ) все эти переменные уничтожаются. При следующем выполнении функции будет применена та же процедура.</p>

<p>Давайте рассмотрим следующий пример, чтобы проиллюстрировать концепцию.</p>

<pre>
function square(x){
  const squaredX = x  x;
  console.log(squaredX); // 25
  return squaredX;
}

const squaredA = square(5);

console.log(squaredA); // 25
console.log(squaredX); // ReferenceError: squaredX is not defined
</pre>

<p>Подумайте об областях, как о временном контексте, к которому имеет доступ только код в этой функции.</p>

<p>Хотя области видимости имеют очень ограниченный срок, ограниченный временем, которое требуется для выполнения функции, с другой стороны, замыкание функции уже создано, когда функция изначально определена. Оно также останется после того, как выполнение было закончено.</p>

<h3>Замыкания</h3>

<p>Как упоминалось ранее, замыкания отвечают за определение того, какие переменные доступны в области видимости функции. Важно понимать, что замыкания предоставляют не копии доступных переменных, а ссылаются на них. Если вы не знакомы со ссылками на JavaScript, ознакомьтесь с этой <a href="https://codeburst.io/explaining-value-vs-reference-in-javascript-647a975e12a0" target="_blank">статьей</a>.</p>

<pre>
let globalString = 'A'

function hello(){
  const localString = 'C'
  console.log(globalString, localString);
}

hello(); // A C

globalString = "B";

hello(); // B C
</pre>

<div class="ad-article">
{% include /ad-type-article.html %}
</div>

<p>Этот пример, наверное, выглядит очень знакомым — ничего особенного. Это объясняет, почему мы с трудом понимаем, насколько мощными могут быть замыкания, поскольку очень часто функции определяют только в глобальной видимости.</p>

<p>Однако, когда функции определены в области видимости другой функции, замыкания включают мощные методы и шаблоны. В объектно-ориентированной архитектуре замыкания предлагают простой, но эффективный способ обеспечения <strong>конфиденциальности данных</strong>. В более функциональных архитектурах замыкания необходимы для <strong>функций высшего порядка</strong>, а также для <strong>частичного применения</strong> и <strong>каррирования</strong>, для более продвинутых методов программирования.</p>

<h3>Функции высшего порядка</h3>

<p>Функция, которая работает с другими функциями, либо принимая их в качестве аргументов, либо возвращая их, называется <strong>функцией высшего порядка</strong>.</p>

<pre>
function createMultiplier(multiplier){
  return function(value){
    return value  multiplier;
  }
}

const multiplyBy2 = createMultiplier(2);

console.log(multiplyBy2(5)); //10
</pre>

<p>Наконец можем испытать силу замыканий. Даже если createMultiplier уже успешно завершен, мы все равно можем получить доступ к его начальному свойству multiplier.</p>

<p>Это возможно, поскольку замыкания сохраняют ссылку на переменные. Они могут даже охватывать несколько областей видимости и не уничтожаться при завершении контекста. Таким образом, мы все еще можем получить доступ к конкретной локальной переменной.</p>

<h3>Конфиденциальность данных</h3>

<pre>
function privateVariables(){
  let privateValue = 100;
  return {
    get: function(){
      return privateValue;
    }
  }
}

console.log(privateVariables.get()); //100
</pre>

<p>Почему замыкания позволяют нам реализовать конфиденциальность данных?</p>

<p>Мы можем просто приложить переменные и разрешить доступ к ним только функциям внутри области действия (внешней) функции.</p>

<p>Вы не можете получить данные из внешней области, кроме как через привилегированные методы объекта. Этот шаблон также позволяет нам программировать интерфейс, а не саму реализацию.</p>

<h3>Задача кодирования: Emoji Tone Picker</h3>

<img src="img/coding/otkrojte-dlya-sebya-silu-zamykanij-v-vuejs/2.jpg" alt="Emoji Tone Picker">

<p>Отлично, вот и вся теория, которая нам нужна для создания чего-то мощного в VueJS и использования силы замыканий!</p>

<p>На самом деле, функции высшего порядка являются наиболее интересным вариантом использования, поскольку у нас уже есть концепция конфиденциальности данных в VueJS.</p>

<p>По сути, компоненты уже предлагают интерфейс через свойства и объект данных, который недоступен извне.</p>

<p>Это компонент, который позволяет пользователю выбирать тон кожи на основе выбора всех доступных тонов, аналогично пользовательскому опыту, известному из текстовых сообщений на смартфоне.</p>

<p>Технически, вы должны попытаться создать компонент, который получает один смайлик в качестве реквизита и использует функции высшего порядка для создания нескольких обработчиков событий клика для выбора разных тонов.</p>

<h3>Оттенок</h3>
<p>Эмодзи могут храниться в виде шестнадцатеричных кодов HTML в строковых значениях. Смайлики сложенных рук - &amp;#x1F64F. Чтобы изменить тон, прикрепите к нему цветовой код. Вы можете найти коды <a href="https://emojiterra.com/folded-hands/">здесь</a>.</p>

<blockquote><em>&amp;#x1F64F + &amp;#x1F3FD = &#x1F64F;&#x1F3FD</em></blockquote>

<h3>Расширяем задачу</h3>

<p>Вы хотите сделать еще один шаг вперед и действительно проверить, справились ли вы с замыканиями? Тогда передайте несколько смайликов и сделайте так, чтобы вы могли менять тон кожи нескольких смайликов сразу. &#x1F4AF</p>

<h3>Заключение</h3>

<p>Замыкания являются причиной, по которой мы можем получить доступ к переменным родительских областей, в то время как связанные функции, возможно, уже завершены.</p>

<p>Мы можем использовать это поведение JavaScript в VueJS для динамического построения методов, основанных на динамических аргументах, без загрязнения наших компонентов огромным количеством переменных и методов.</p>

<p>Спасибо за прочтение &#x1F64C;</p>

<p class="source">Перевод статьи <a href="https://medium.freecodecamp.org/closures-vuejs-higher-order-functions-emojipicker-f10d3c249a12" target="_blank">&laquo;Discover the power of closures in VueJS&raquo;</a></p>
